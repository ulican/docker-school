version: 2.1

# Executors define reusable execution environments
# Node executor provides Docker + npm for tooling flexibility
executors:
  docker-executor:
    docker:
      - image: cimg/node:18.20
    working_directory: ~/project

jobs:
  build:
    executor: docker-executor
    steps:
      - checkout
      - setup_remote_docker
      - run:
          name: Build Docker image
          command: |
            echo "Building Docker image..."
            # Using commit SHA for immutable image tagging - enables rollback & traceability
            docker build -t sod-static:$CIRCLE_SHA1 .
            echo "Build completed: sod-static:$CIRCLE_SHA1"
      - run:
          name: Save Docker image
          command: |
            mkdir -p /tmp/workspace
            # Serialize image to avoid rebuilding in downstream jobs - saves time & compute
            docker save sod-static:$CIRCLE_SHA1 -o /tmp/workspace/image.tar
      - persist_to_workspace:
          root: /tmp/workspace
          paths:
            - image.tar

  test:
    executor: docker-executor
    steps:
      - checkout
      - setup_remote_docker
      - attach_workspace:
          at: /tmp/workspace
      - run:
          name: Load Docker image
          command: |
            docker load -i /tmp/workspace/image.tar
      - run:
          name: Test Docker container
          command: |
            echo "Testing website..."
            # Black-box integration test - verify service runs as expected in production-like env
            docker run -d --name test-container -p 9090:80 sod-static:$CIRCLE_SHA1
            sleep 10

            # Health checks - fail fast if service isn't responsive
            docker ps | grep test-container
            docker exec test-container curl -f localhost || exit 1

            echo "Tests passed"
      - run:
          name: Cleanup test container
          command: |
            docker stop test-container || true
            docker rm test-container || true
          when: always

  deploy:
    executor: docker-executor
    steps:
      - run:
          name: Deploy to staging
          command: |
            echo "Deploying to staging environment"
            echo "Image: sod-static:$CIRCLE_SHA1"
            echo "Branch: $CIRCLE_BRANCH"
            echo "Build number: $CIRCLE_BUILD_NUM"
            echo "Deploy completed"
            # Production: Replace with actual deployment commands
            # Examples:
            # - kubectl set image deployment/app container=sod-static:$CIRCLE_SHA1
            # - docker push $REGISTRY/sod-static:$CIRCLE_SHA1
            # - terraform apply -var="image_tag=$CIRCLE_SHA1"

  notify:
    executor: docker-executor
    steps:
      - run:
          name: Send notification
          command: |
            echo "Pipeline completed!"
            echo "Status: Success"
            echo "Repository: $CIRCLE_PROJECT_REPONAME"
            echo "Commit: $CIRCLE_SHA1"
            echo "Branch: $CIRCLE_BRANCH"

            # Production: Integrate with notification systems
            # Examples:
            # - Slack webhook for team notifications
            # - Email alerts for deployment status
            # - Monitoring system integration
            # curl -X POST -H 'Content-type: application/json' \
            #   --data '{"text":"Deployment completed for '$CIRCLE_PROJECT_REPONAME'"}' \
            #   $SLACK_WEBHOOK_URL

# Workflows orchestrate job execution with dependency management
workflows:
  version: 2
  build-test-deploy:
    jobs:
      - build:
          filters:
            branches:
              only: main
      - test:
          requires:
            - build
          filters:
            branches:
              only: main
      - deploy:
          requires:
            - test
          filters:
            branches:
              only: main
      - notify:
          requires:
            - build
            - test
            - deploy
          filters:
            branches:
              only: main
